// Generated by CoffeeScript 1.3.3
(function() {

  define([], function() {
    var Complex, dft, inverseDft, sign, squareWave;
    sign = function(x) {
      if (x >= 0) {
        return 1;
      } else {
        return -1;
      }
    };
    squareWave = function(xValues, amplitude, period, phase) {
      var x, _i, _len, _results;
      if (phase == null) {
        phase = 0;
      }
      _results = [];
      for (_i = 0, _len = xValues.length; _i < _len; _i++) {
        x = xValues[_i];
        _results.push(amplitude * sign(Math.sin(2 * Math.PI * x / period + phase)));
      }
      return _results;
    };
    Complex = (function() {

      function Complex(real, imaginary) {
        this.real = real;
        this.imaginary = imaginary;
      }

      return Complex;

    })();
    dft = function(values, numSeriesTerms) {
      var coefs, i, imaginaryCoef, k, realCoef, theta, w0, wk, y, _i, _j, _len;
      if (numSeriesTerms == null) {
        numSeriesTerms = values.length;
      }
      coefs = [];
      w0 = 2 * Math.PI / values.length;
      for (k = _i = 0; 0 <= numSeriesTerms ? _i < numSeriesTerms : _i > numSeriesTerms; k = 0 <= numSeriesTerms ? ++_i : --_i) {
        realCoef = imaginaryCoef = 0;
        wk = w0 * k;
        for (i = _j = 0, _len = values.length; _j < _len; i = ++_j) {
          y = values[i];
          theta = wk * i;
          realCoef += y * Math.cos(theta);
          imaginaryCoef += y * -1 * Math.sin(theta);
        }
        coefs[k] = new Complex(realCoef, imaginaryCoef);
      }
      return coefs;
    };
    inverseDft = function(complexCoefs, xValues) {
      var complexCoef, i, imaginaryValAtX, k, numCoefs, numXValues, output, realValAtX, theta, w0x, x, _i, _j, _len, _len1;
      numCoefs = complexCoefs.length;
      numXValues = xValues.length;
      output = [];
      for (i = _i = 0, _len = xValues.length; _i < _len; i = ++_i) {
        x = xValues[i];
        realValAtX = 0;
        imaginaryValAtX = 0;
        w0x = 2 * Math.PI * x / numXValues;
        for (k = _j = 0, _len1 = complexCoefs.length; _j < _len1; k = ++_j) {
          complexCoef = complexCoefs[k];
          theta = w0x * k;
          realValAtX += complexCoef.real * Math.cos(theta);
          imaginaryValAtX -= complexCoef.imaginary * Math.sin(theta);
        }
        output[i] = 2 / numXValues * (realValAtX + imaginaryValAtX);
      }
      return output;
    };
    return {
      squareWave: squareWave,
      Complex: Complex,
      dft: dft,
      inverseDft: inverseDft
    };
  });

}).call(this);
